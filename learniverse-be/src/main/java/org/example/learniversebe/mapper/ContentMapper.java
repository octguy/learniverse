package org.example.learniversebe.mapper;

import org.example.learniversebe.dto.request.CreatePostRequest;
import org.example.learniversebe.dto.request.CreateQuestionRequest;
import org.example.learniversebe.dto.response.*;
import org.example.learniversebe.model.Content;
import org.example.learniversebe.model.ContentTag;
import org.mapstruct.*;
import org.mapstruct.factory.Mappers;
import org.springframework.data.domain.Page;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Mapper interface for converting between Content entity and various Content DTOs (Post/Question).
 * Uses other mappers (UserMapper, TagMapper, AttachmentMapper, AnswerMapper) for nested objects.
 */
// Ensure all necessary mappers used within this mapper are listed in 'uses'
@Mapper(componentModel = "spring", uses = {UserMapper.class, TagMapper.class, AttachmentMapper.class, AnswerMapper.class})
public interface ContentMapper {
    /**
     * Maps CreatePostRequest DTO to Content entity. Sets contentType to POST.
     * Ignores fields that are auto-generated, managed by lifecycle callbacks,
     * set in the service layer, or handled separately (like tags, attachments).
     */
    @Mapping(target = "contentType", constant = "POST")
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "author", ignore = true) // Set in Service
    @Mapping(target = "slug", ignore = true)   // Generated in Service or PrePersist
    @Mapping(target = "status", ignore = true) // Default or set in Service
    @Mapping(target = "viewCount", ignore = true)
    @Mapping(target = "commentCount", ignore = true)
    @Mapping(target = "reactionCount", ignore = true)
    @Mapping(target = "bookmarkCount", ignore = true)
    @Mapping(target = "shareCount", ignore = true)
    @Mapping(target = "voteScore", ignore = true)
    @Mapping(target = "acceptedAnswer", ignore = true)
    @Mapping(target = "answerCount", ignore = true)
    @Mapping(target = "isAnswered", ignore = true)
    @Mapping(target = "publishedAt", ignore = true) // Set in Service upon publishing
    @Mapping(target = "lastEditedAt", ignore = true)
    @Mapping(target = "searchVector", ignore = true) // Generated by DB trigger
    @Mapping(target = "contentTags", ignore = true) // Handled separately in Service using ContentTagRepository
    @Mapping(target = "attachments", ignore = true) // Handled separately in Service
    @Mapping(target = "createdAt", ignore = true)   // Set by @PrePersist
    @Mapping(target = "updatedAt", ignore = true)   // Set by @PrePersist/@PreUpdate
    @Mapping(target = "deletedAt", ignore = true)   // Set by @SQLDelete
    Content createPostRequestToContent(CreatePostRequest request);

    /**
     * Maps CreateQuestionRequest DTO to Content entity. Sets contentType to QUESTION.
     * Ignores fields similarly to the createPostRequestToContent mapping.
     */
    @Mapping(target = "contentType", constant = "QUESTION")
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "author", ignore = true)
    @Mapping(target = "slug", ignore = true)
    @Mapping(target = "status", ignore = true)
    @Mapping(target = "viewCount", ignore = true)
    @Mapping(target = "commentCount", ignore = true)
    @Mapping(target = "reactionCount", ignore = true)
    @Mapping(target = "bookmarkCount", ignore = true)
    @Mapping(target = "shareCount", ignore = true)
    @Mapping(target = "voteScore", ignore = true)
    @Mapping(target = "acceptedAnswer", ignore = true)
    @Mapping(target = "answerCount", ignore = true)
    @Mapping(target = "isAnswered", ignore = true)
    @Mapping(target = "publishedAt", ignore = true)
    @Mapping(target = "lastEditedAt", ignore = true)
    @Mapping(target = "searchVector", ignore = true)
    @Mapping(target = "contentTags", ignore = true)
    @Mapping(target = "attachments", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    Content createQuestionRequestToContent(CreateQuestionRequest request);

    // --- Mappings from Content Entity to Response DTOs ---

    /**
     * Maps a Content entity to a detailed PostResponse DTO.
     * Uses the custom mapping method for tags.
     * Ignores user-specific fields which need logic in the Service.
     */
    // MapStruct uses the 'uses' attribute to find appropriate mappers for nested fields (author, attachments)
    @Mapping(source = "contentTags", target = "tags", qualifiedByName = "contentTagsToTagResponses")
    @Mapping(target = "bookmarkedByCurrentUser", ignore = true) // Requires specific logic in Service
    @Mapping(target = "currentUserReaction", ignore = true)   // Requires specific logic in Service
    PostResponse contentToPostResponse(Content content);

    /**
     * Maps a Content entity to a summary PostSummaryResponse DTO.
     * Uses the custom mapping method for tags.
     * Ignores bodyExcerpt which needs logic in the Service.
     */
    @Mapping(source = "contentTags", target = "tags", qualifiedByName = "contentTagsToTagResponses")
    @Mapping(target = "bodyExcerpt", ignore = true) // Requires specific logic in Service
    PostSummaryResponse contentToPostSummaryResponse(Content content);

    /**
     * Maps a Content entity to a detailed QuestionResponse DTO.
     * Maps acceptedAnswer ID.
     * Ignores the list of answers (should be fetched separately).
     * Ignores user-specific fields.
     */
    @Mapping(source = "contentTags", target = "tags", qualifiedByName = "contentTagsToTagResponses")
    @Mapping(source = "acceptedAnswer.id", target = "acceptedAnswerId") // Map ID from a nested object
    @Mapping(target = "answers", ignore = true) // Avoid loading all answers by default; use separate API
    @Mapping(target = "bookmarkedByCurrentUser", ignore = true)
    @Mapping(target = "currentUserReaction", ignore = true)
    //@Mapping(target = "currentUserVote", ignore = true) // Add if needed, requires logic
    QuestionResponse contentToQuestionResponse(Content content);

    /**
     * Maps a Content entity to a summary QuestionSummaryResponse DTO.
     * Maps acceptedAnswer ID.
     */
    @Mapping(source = "contentTags", target = "tags", qualifiedByName = "contentTagsToTagResponses")
    @Mapping(source = "acceptedAnswer.id", target = "acceptedAnswerId")
    QuestionSummaryResponse contentToQuestionSummaryResponse(Content content);

    /**
     * Helper method used by MapStruct (@Named) to map a Set of join entities (ContentTag)
     * to a Set of target DTOs (TagResponse). It extracts the Tag from the join entity
     * and uses the TagMapper (injected via @Context) to perform the final conversion.
     *
     * @param contentTags The set of ContentTag join entities.
     * @return A set of TagResponse DTOs, or an empty set if input is null/empty.
     */
    @Named("contentTagsToTagResponses")
    default Set<TagResponse> mapContentTagsToTagResponses(Set<ContentTag> contentTags) {
        if (contentTags == null || contentTags.isEmpty()) {
            return Collections.emptySet();
        }
        // Use the injected TagMapper instance provided by @Context
        TagMapper tagMapper = Mappers.getMapper(TagMapper.class);
        return contentTags.stream()
                .map(ContentTag::getTag) // Get the Tag entity from ContentTag
                .map(tagMapper::toTagResponse) // Use TagMapper to convert Tag -> TagResponse
                .collect(Collectors.toSet());
    }

    // --- Utility Methods for Pagination ---

    /**
     * Converts a Page<Content> (from repository) to PageResponse<PostSummaryResponse>.
     * Uses the mapping methods defined above.
     * 'this' refers to the instance of ContentMapper being used.
     */
    default PageResponse<PostSummaryResponse> contentPageToPostSummaryPage(Page<Content> page) {
        if (page == null) return null;
        List<PostSummaryResponse> dtoList = page.getContent().stream()
                .map(this::contentToPostSummaryResponse) // 'this' refers to the mapper instance
                .collect(Collectors.toList());
        return PageResponse.fromPage(page, dtoList);
    }

    /**
     * Converts a Page<Content> (from repository) to PageResponse<QuestionSummaryResponse>.
     * Uses the mapping methods defined above.
     */
    default PageResponse<QuestionSummaryResponse> contentPageToQuestionSummaryPage(Page<Content> page) {
        if (page == null) return null;
        List<QuestionSummaryResponse> dtoList = page.getContent().stream()
                .map(this::contentToQuestionSummaryResponse) // 'this' refers to the mapper instance
                .collect(Collectors.toList());
        return PageResponse.fromPage(page, dtoList);
    }
}